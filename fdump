#!/usr/bin/env python3

"""File hexdump program.

usage: fdump [-h] [-c <codename>] [-o <outfile>] <infile>

where <codename> is the name of the codepage to be used,
      <infile> is the file to produce the hexdump of, and
      <outfile> is the output file of fdump, if supplied.

If the "-c <codename>" option is used then "unprintable"
characters are those unprintable in the named codepage.
Recognized <codename>s are:
    ASCII                       the default
    ISO-8859-1 or Latin-1
Names are case-insensitive.
"""

import sys
import getopt
import string
import os.path


# list of recognized code names
KnownCodes = ['ascii', 'iso-8859-1', 'latin-1',]

# code we are using
CodeName = 'ascii'

# size of hex/char buffers in the output line
HEXLEN = 48
CHARLEN = 16


def isprintable(ch):
    """Returns True if byte value 'ch' is printable.

    Uses 'CodeName' to determine what is printable.
    """

    if CodeName == 'ascii':
        return ord(' ') <= ch <= ord('~')
    elif CodeName in ['latin-1', 'iso-8859-1']:
        # we can print the UNICODE printable chars in the 8-bit set
        # because they mirror the Latin-1 codepage
        return ord(' ') <= ch <= ord('~') or 0xA1 <= ch <= 0XFF

def hexdump(filename, outfile=sys.stdout):
    """A function that generates a 'hex dump' of a file.

    filename  name of the file to dump
    outfile   file-like object the hex data is written to

    Calling this function for a file containing
    'The quick brown fox\n\tjumps over the lazy dog.'
    returns a string containing:
    0000  54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20  |The quick brown |  0
    0010  66 6f 78 0a 09 6a 75 6d 70 73 20 6f 76 65 72 20  |fox..jumps over |  16
    0020  74 68 65 20 6c 61 7a 79 20 64 6f 67 2e           |the lazy dog.|     32

    +---------+---------+---------+---------+---------+---------+---------+-------
    0         1         2         3         4         5         6         7
    0         0         0         0         0         0         0         0

    Each line of the dump contains info about 16 bytes of the input string.

    The 4 hex digits starting at column 0 are the offset in hex of the first byte.

    The 16 hex digit pairs starting at column 6 and ending at column 52 are the
    16 byte values in hex.

    The characters spanning columns 56-71 are the 16 printable characters.  If a
    character is not printable it is replaced by a '.' character.

    The decimal number starting at column 75 is the decimal offset of the first
    byte in the line.
    """

    # we used to read the entire file into memory but this delayed things
    # when doing "fdump really_big_file | more", so now read 16 bytes at a time
    with open(filename, 'rb', 8192) as f:
        offset = 0
        while True:
            data = f.read(16)   # read up to 16 bytes at a time
            if len(data) == 0:
                break

            try:
                outfile.write(hexdump_line(data, offset) + '\n')
            except IOError:
                break

            offset += 16

def hexdump_line(bseq, offset):
    """Generate one line of fdump output.

    bseq    byte sequence to convert (16 bytes or less)
    offset  offset from start of dump
    """

    hexbuff = ''
    chbuff = ''
    for ch in bseq:
        hexbuff += '%02x ' % ch
        if isprintable(ch):
            chbuff += chr(ch)
        else:
            chbuff += '.'
    hexbuff = (hexbuff + ' '*HEXLEN)[:HEXLEN]
    chbuff = (chbuff + '|' + ' '*CHARLEN)[:CHARLEN+1]

    return f'{offset:04X}  {hexbuff} |{chbuff}  {offset}'


################################################################################


if __name__ == "__main__":

    def usage(msg=None):
        if msg:
            print('-' * 60)
            print(msg)
            print('-' * 60, '\n')
        print(__doc__)
    
    def main(argv):
        global CodeName

        try:
            opts, args = getopt.gnu_getopt(argv, "c:ho:",
                                           ["code=", "help", "outfile="])
        except getopt.GetoptError:
            usage('Bad option')
            return 10

        outfile = sys.stdout     # default output
    
        for opt, arg in opts:
            if opt in ("-c", "--code"):
                CodeName = arg.lower()
            if opt in ("-o", "--outfile"):
                outfile = open(arg, 'w')
            if opt in ("-h", "--help"):
                usage()
                return 0
    
        if len(args) != 2:
            usage()
            return 10
    
        if CodeName not in KnownCodes:
            usage(f'Bad code page name: {CodeName}')
            return 10

        filename = args[1]
        try:
            f = open(filename)
        except IOError:
            print(f"Sorry, can't find file '{filename}'")
            return 10
        f.close()
    
        hexdump(filename, outfile=outfile)

    sys.exit(main(sys.argv))
